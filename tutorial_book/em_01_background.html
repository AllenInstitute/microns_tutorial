<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.546">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>EM Connectomics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="em_01_background_files/libs/clipboard/clipboard.min.js"></script>
<script src="em_01_background_files/libs/quarto-html/quarto.js"></script>
<script src="em_01_background_files/libs/quarto-html/popper.min.js"></script>
<script src="em_01_background_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="em_01_background_files/libs/quarto-html/anchor.min.js"></script>
<link href="em_01_background_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="em_01_background_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="em_01_background_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="em_01_background_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="em_01_background_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#what-questions-can-be-addressed-by-connectomic-datasets" id="toc-what-questions-can-be-addressed-by-connectomic-datasets" class="nav-link" data-scroll-target="#what-questions-can-be-addressed-by-connectomic-datasets">What questions can be addressed by connectomic datasets?</a></li>
  <li><a href="#the-microns-dataset" id="toc-the-microns-dataset" class="nav-link" data-scroll-target="#the-microns-dataset">The MICrONs dataset</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">EM Connectomics</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/minnie-3d-cells.png" class="img-fluid figure-img"></p>
<figcaption>A 3D rendering of cells in the MICrONs dataset.</figcaption>
</figure>
</div>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>The function of the nervous system arises out of a combination of the properties of individual neurons and the properties of how they are connected into a larger network. The central goal of connectomics is to produce <em>complete maps</em> of the <em>connectivity</em> of the nervous system with <em>synaptic resolution</em> and analyze them to better understand the organization, development, and function of the nervous system. Electron microscopy (EM) has been a central tool in achieving these aims for two key reasons: 1) EM can easily image nanometer-scale structures such as synapses. This allows one to unambiguously observe chemical synapses and, if pushed to high enough resolution, gap junctions. (Note that the MICrONs dataset is not high enough resolution to unambiguously observe gap junctions.) 2) Dense staining methods allow the complete observation of a of rich collection of cellular features, including membranes, nuclei, mitochondria, and much more. This allows the reconstruction of the complete morphology of cells.</p>
<p>The general approach to EM involves staining tissue with heavy metals and using electrons to imaging thin sections of tissue. Sections can either be created by cutting tissue into slices (“serial section”) followed by imaging, or by imaging the face of a block and shaving off a thin layer of tissue after each run (“block face”). In both approaches, each section corresponds to only 30–50 nanometers of thickness (although it can be a millimeter wide), and thus assembling a substantial volumes involves thousands or tens of thousands of sections in a row. Finally, computational methods are used to align and assemble the sections into a single volume and then to segment the volume into individual cells and synapses.</p>
<p>While the resolution afforded by EM has been used to study the nervous system since 1959, the first true “connectomics” project that merged dense mapping of neurons and synaptic connectivity was the study of the nematode <em>C. elegans</em> led by Sydney Brenner, John White, and others. Advances in EM methods and computational methods in the last ten years have allowed tremendous scaling of connectomics datasets. The largest current mammalian datasets, including the MICrONs volume will consider here, now span more than a cubic millimeter, and invertebrate datasets now can cover the entire brain of a fruit fly.</p>
</section>
<section id="what-questions-can-be-addressed-by-connectomic-datasets" class="level2">
<h2 class="anchored" data-anchor-id="what-questions-can-be-addressed-by-connectomic-datasets">What questions can be addressed by connectomic datasets?</h2>
<p>For invertebrates like the fruit fly, the nervous system is highly stereotyped in both the composition of cells and how they connect to one another. Indeed, in the fly many cell types exist as a single pair of cells, one from the left and one from the right hemisphere. Connectomic maps from one individual can thus act as a nearly universal map of the brain and powerfully inform theoretical and experimental studies.</p>
<p>In mouse cortex, this same type of stereotypy does not apply. There is no one-to-one match between any given cell in the brain of one mouse and another, and thousands of cells in a cortical area can belong to the same cell type. Because of this, the types of questions one can ask differ, but dense reconstruction of anatomy and connectivity still can be a powerful source of insight into questions like:</p>
<ul>
<li>What morphological or connectivity-based cell types can be found?</li>
<li>What are the properties of the excitatory networks in cortex and how might they relate to learning rules?</li>
<li>What rules dictate how inhibitory cells distribute their synaptic output across target cell types?</li>
</ul>
<p>In some datasets, such as the MICrONs dataset, calcium imaging of the same tissue was performed prior to preparing the structural EM volume. In that case, we can address additional questions like:</p>
<ul>
<li>How do functional responses relate to the morphology of cells?</li>
<li>How do functional responses relate to the connectivity of cells?</li>
</ul>
<p>In addition, a whole host of non-neuronal cells are also present, such as astrocytes, oligodendrocytes, microglia, and pericytes. Many people are interested in studying the relationship between these cells and neurons, and connectomic datasets can be a powerful tool to discovery this structural context.</p>
</section>
<section id="the-microns-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-microns-dataset">The MICrONs dataset</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For more complete details about the generation of the volume, please see <span class="citation" data-cites="schneider-mizell2023">(<a href="#ref-schneider-mizell2023" role="doc-biblioref">Schneider-Mizell et al. 2023</a>)</span>.</p>
</div>
</div>
<p>The MICrONs dataset is an EM volume of mouse visual cortex that spans all cortical layers, and extends approximately 1 mm in width by 0.5 mm in depth, collected as a collaboration between the Allen Institute for Brain Science, Baylor College of Medicine, and Princeton University. The goal of this dataset was to produce a so-called “functional connectomics” volume, where the same population of neurons could be measured with both calcium imaging to record functional properties and EM to describe synapse-resolution structural properties.</p>
<p>To link structure and function, excitatory neurons were genetically labeled with GCaMPs and imaged under a battery of natural movies and parametric stimuli by the Tolias lab, then at Baylor College of Medicine. The mouse was shipped to the Allen Institute and the same cortical region was prepared for EM, with more than 25,000 sections cut from the block and imaged across a small fleet of electron microscopes. In order to capture the interactions between different visual regions, the volume location is at the edge of primary visual cortex and extends into higher visual areas AL and RL <span class="citation" data-cites="glickfeld_higher-order_2017">(<a href="#ref-glickfeld_higher-order_2017" role="doc-biblioref">Glickfeld and Olsen 2017</a>)</span>. Imagery was then aligned and segmented by the team of Sebastian Seung at Princeton, who also automatically detected synapses and nuclei. A team of proofreaders at Johns Hopkins Applied Physics Laboratory helped correct the largest types of errors in the segmentation, leaving virtually every neuron as a distinct object, and coregister tens of thousands of neurons to the functional data. Further analysis at the Allen Institute and elsewhere has focused on curating a map of cell types across the entire dataset, and generating a database to link synapses, cell types, and more to the morphology of individual cells.</p>
<p>The result is a cubic millimeter scale dataset with a rich collection of information and the potential for a range of studies, with strengths and limitations due to the current state of proofreading and needs of the functional data collection.</p>
<p>The next sections of the Data Book will introduce how to access the various parts of the dataset and give some guidance about how to use them.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-glickfeld_higher-order_2017" class="csl-entry" role="listitem">
Glickfeld, Lindsey L., and Shawn R. Olsen. 2017. <span>“Higher-<span>Order Areas</span> of the <span>Mouse Visual Cortex</span>.”</span> <em>Annual Review of Vision Science</em> 3: 251–73. <a href="https://doi.org/10.1146/annurev-vision-102016-061331">https://doi.org/10.1146/annurev-vision-102016-061331</a>.
</div>
<div id="ref-schneider-mizell2023" class="csl-entry" role="listitem">
Schneider-Mizell, Casey M., Agnes Bodor, Derrick Brittain, JoAnn Buchanan, Daniel J. Bumbarger, Leila Elabbady, Daniel Kapner, et al. 2023. <span>“Cell-Type-Specific Inhibitory Circuitry from a Connectomic Census of Mouse Visual Cortex.”</span> <span>bioRxiv</span>. <a href="https://doi.org/10.1101/2023.01.23.525290">https://doi.org/10.1101/2023.01.23.525290</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>