<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.546">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Dash Apps</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="em_05_dash_apps_files/libs/clipboard/clipboard.min.js"></script>
<script src="em_05_dash_apps_files/libs/quarto-html/quarto.js"></script>
<script src="em_05_dash_apps_files/libs/quarto-html/popper.min.js"></script>
<script src="em_05_dash_apps_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="em_05_dash_apps_files/libs/quarto-html/anchor.min.js"></script>
<link href="em_05_dash_apps_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="em_05_dash_apps_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="em_05_dash_apps_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="em_05_dash_apps_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="em_05_dash_apps_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#table-viewer" id="toc-table-viewer" class="nav-link active" data-scroll-target="#table-viewer">Table Viewer</a></li>
  <li><a href="#connectivity-and-cell-type-viewer" id="toc-connectivity-and-cell-type-viewer" class="nav-link" data-scroll-target="#connectivity-and-cell-type-viewer">Connectivity and Cell Type Viewer</a>
  <ul class="collapse">
  <li><a href="#visualization-tabs" id="toc-visualization-tabs" class="nav-link" data-scroll-target="#visualization-tabs">Visualization tabs</a></li>
  <li><a href="#connectivity-table" id="toc-connectivity-table" class="nav-link" data-scroll-target="#connectivity-table">Connectivity Table</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Dash Apps</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>We have created two webapps to help explore and visualize the data.</p>
<p>These apps were created using the <a href="https://plotly.com/dash/">Dash</a> framework, hence the name.</p>
<section id="table-viewer" class="level2">
<h2 class="anchored" data-anchor-id="table-viewer">Table Viewer</h2>
<p>The <a href="https://minnie.microns-daf.com/dash/datastack/minnie65_public/apps/table_viewer/?datastack=%22minnie65_public%22"><strong>Table Viewer</strong></a> app allows you to query individual tables in the database, filter them, and visualize the results in Neuroglancer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/table-viewer.png" class="img-fluid figure-img"></p>
<figcaption>Table viewer input options</figcaption>
</figure>
</div>
<p>In the Table Viewer, you first select one of the tables from a dropdown in the upper left side.</p>
<p>The <code>Live Query</code> option is not relevent for the public data.</p>
<p>Filter options allow you to limit the query to a subset of the data, if desired. Note that filtering can occur in the tables afterward as well.</p>
<p>The <code>Cell IDs</code> field lets you put in one or more root IDs, cell IDs (i.e.&nbsp;“Nucleus ID”), or IDs from the annotation table being queried. Note that if you use this option, you havet to set the dropdown to the appropriate ID type.</p>
<p>The <code>Value Search</code> field lets you search for a particular value, such as a specific cell type.</p>
<p>Once you have selected your table and set any pre-query filters, click the <code>Submit</code> button to run the query. When the query is done, a green bar will appear below the query input stating that it’s showing the state of the table you queried.</p>
<p>The first set of controls allow you to build a Neuroglancer link for the whole table using the “Generate Link” button.</p>
<p>Optionally, if you would like to make a link where different values of a given column — example, different cell types — are shown in different layers, you can turn on the “Group Annotations” toggle on the right and select the column you want to use for groupings.</p>
<p>After setting these controls, click the “Generate Link” button to create the Neuroglancer link.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/table-viewer-table.png" class="img-fluid figure-img"></p>
<figcaption>Table viewer query results.</figcaption>
</figure>
</div>
<p>The table itself is shown below the controls. You can sort the table by clicking on the column headers, and filter the table by typing in the filter box below the column headers.</p>
<p>For example, if you want to find only cells with cell type “5P-NP” in a cell type column, simply type <code>5P-NP</code> in the box under the column header. Similarly, to find only cells whose nucleus volume is greater than 500, type <code>&gt;500</code> in the box under the <code>volume</code> column header in a table with nucleus information.</p>
<p>In addition, individual rows can be selected by clicking on the checkbox to the left of the row.</p>
<p>The left button along the top is a Neuroglancer link specific to the selected rows, if present, or the table as filtered if no rows are selected.</p>
<p>The orange button will deselect all checkboxes, and the “Export to CSV” will download the table as filtered to a CSV.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>If the table is too large (well beyond 10,000 rows), there are too many annotations to show in Neuroglancer and no link will be automatically generated.</p>
</div>
</div>
</section>
<section id="connectivity-and-cell-type-viewer" class="level2">
<h2 class="anchored" data-anchor-id="connectivity-and-cell-type-viewer">Connectivity and Cell Type Viewer</h2>
<p>The other tool is the <a href="https://minnie.microns-daf.com/dash/datastack/minnie65_public/apps/connectivity/?datastack=%22minnie65_public%22"><strong>Connectivity Viewer</strong></a>, which is designed to let you glance at the synaptic output or input of a given cell and group connectivity by cell type or other annotations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/connectivity-viewer-top.png" class="img-fluid figure-img"></p>
<figcaption>Connectivity viewer input options.</figcaption>
</figure>
</div>
<p>Along the top, you can enter an ID (either a root ID or a cell ID) and, optionally, a table to use to define cell types for synaptic partners. ::: {.callout-note} Note that if you want to use cell IDs from the annotation table, you must select the <code>Nucleus ID</code> option from the dropdown next to the entry box. :::</p>
<p>The default cell type table option, <code>aibs_soma_nuc_metamodel_preds_v117</code>, is a good all-purpose table predicting coarse cell types on as many cells as possible.</p>
<p>The table <code>aibs_metamodel_mtypes_v661_v2</code> is the most current version version of the cell type classification, described in <span class="citation" data-cites="schneider-mizell2023">(<a href="#ref-schneider-mizell2023" role="doc-biblioref">Schneider-Mizell et al. 2023</a>)</span>.</p>
<p>Pressing “Submit” will query the database for the cell and its synapses.</p>
<p>Once completed, you will see the bar under the input options turn green and report the data that it is displaying. For example, if we query root id <code>864691135408247241</code> and the default cell type table, we will see the following:</p>
<p><img src="img/connectivity-viewer-success.png" class="img-fluid"></p>
<p>Importantly, the data displayed below will match whatever is in this bar —&nbsp;if your query takes a long time or fails for some reason (i.e.bad internet, server error), the tables displayed might be stale.</p>
<p>There are two locations the resulting data is displayed, as we’ll see below. First, a bar of tabs allows you to quickly visualize the data in different ways. Second, the table can present synaptic partners in a more detailed way.</p>
<section id="visualization-tabs" class="level3">
<h3 class="anchored" data-anchor-id="visualization-tabs">Visualization tabs</h3>
<p>The first and default option in the tabs is <strong>Tables Only</strong> which doesn’t actually show any data. This is merely a placeholder to let you look directly at the tablular data below.</p>
<p>The next tab, <strong>Plots</strong> lets you visualize the synaptic output of a neuron.</p>
<p>We focus on synaptic output only right now, because the data quality is such that automated dendritic reconstructions are reliable, but automated axon reconstructions are not (see <a href="em_03_proofreading.html">Proofreading section</a>). Because of that, if a neuron has been proofread we trust the cell types of its postsynaptic partners as a group but do not trust the cell types of its presynaptic partners.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/connectivity-viewer-plots.png" class="img-fluid figure-img"></p>
<figcaption>Plot view. Left, violin plot of the synaptic distribution of the queried cell. Blue/left is the distribution of the cortical depth of input synapses along, red/right is the distribution of cortical depth of synaptic outputs. Approximate layers are shown. Center, a scatterplot with a dot for each synaptic output of the queried cell that is onto a target with a unique cell body (i.e.&nbsp;no dendritic fragments and no cells erroneously merged into other cells). The y-axis is the depth of the synapse itself, while the x-axis is the depth of the cell body of the target neuron. If a cell body categroy is selected, the dots are colored by the cell type of the target neuron. Right, a bar plot showing of the number of synapses onto target cell types.</figcaption>
</figure>
</div>
<p>These plots are designed to give you a quick overview of a cell’s synaptic outputs.</p>
<p>To add a particularly cell type column, use the <code>Color by value:</code> dropdown below the row of plots to select a column to color by.</p>
<p>These plots are handled in <a href="https://plotly.com/python/">Plotly</a>, so you can hover over the plots to see more information, and you can click and drag to zoom in on a particular region and save by clicking on the camera icon. For the scatterplot, you can also turn on and off individual types by clicking on the legend.</p>
<p>The next tab, <strong>Neuroglancer Links</strong> lets you visualize the synapses of a neuron in Neuroglancer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/connectivity-viewer-ngl.png" class="img-fluid figure-img"></p>
<figcaption>Neuroglancer links. From left to right: Show all synaptic inputs to the cell, show all synaptic inputs to the cell grouped into different layers by value in the associated table (e.g.&nbsp;cell type), show all synaptic outputs of the cell, show all synaptic outputs of the cell grouped into different layers by value in the associated table (e.g.&nbsp;cell type). Below the dropdown specifies which column to use if grouping annotations. The <code>Include No Type</code> toggle specifies whether to show synapses with cells that have no cell type annotation in the grouped cases.</figcaption>
</figure>
</div>
<p>The Neuroglancer links generated by these buttons will span all synapses of the queried cell, and do not reflect the filtering in the table below. The synapse annotations are also associated with the synaptic partners, making it easy to browse through a broad sampling of synaptic connectivity.</p>
</section>
<section id="connectivity-table" class="level3">
<h3 class="anchored" data-anchor-id="connectivity-table">Connectivity Table</h3>
<p>The table below shows a table of all synaptic partners.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/connectivity-viewer-table-view.png" class="img-fluid figure-img"></p>
<figcaption>Table view options.</figcaption>
</figure>
</div>
<p>One of the first things you can see in the table viewer is that it is split into two tabs, <strong>Input</strong> and <strong>Output</strong>, with the tab names for each showing the total number of synapses in each category.</p>
<p>To move between them, just click the tab you want.</p>
<p>Above the Input/Ouput tabs is a link to the Neuroglancer view of the synapses show in the table, after filtering and/or selecting a subset of rows.</p>
<p>The table view here is similar to in the Annotation Table Viewer described above. You can sort the table by clicking column headers, filter the table using the row underneath the headers, and select individual rows. If you select individual rows, the Neuroglancer link will group all synapses from each partner together, making it particularly easy to see how synaptic connectivity relates to neuronal anatomy.</p>
<p>The default sorting of the table is by total number of synapses, but note that both summed total synapse size (<code>net_size</code>) and average synapse size (<code>mean_size</code>) are also shown. These can be particularly important values when thinking about connectivity between excitatory neurons.</p>
<p>A CSV file of the entire table can be downloaded by clicking the “Export to CSV” button.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-schneider-mizell2023" class="csl-entry" role="listitem">
Schneider-Mizell, Casey M., Agnes Bodor, Derrick Brittain, JoAnn Buchanan, Daniel J. Bumbarger, Leila Elabbady, Daniel Kapner, et al. 2023. <span>“Cell-Type-Specific Inhibitory Circuitry from a Connectomic Census of Mouse Visual Cortex.”</span> <span>bioRxiv</span>. <a href="https://doi.org/10.1101/2023.01.23.525290">https://doi.org/10.1101/2023.01.23.525290</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>