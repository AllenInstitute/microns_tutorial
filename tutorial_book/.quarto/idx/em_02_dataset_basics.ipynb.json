{"title":"Dataset Basics","markdown":{"yaml":{"title":"Dataset Basics","format":{"html":{"toc":true}},"bibliography":"references.bib"},"headingText":"Dataset Information Hub","containsRefs":false,"markdown":"\n\nOne of the more complicated things about using connectomics data is that it's both highly multimodal — there are images, tables, meshes, and more — and that it has been designed to be dynamic, as the segmentation changes with proofeading and carries changes to synaptic connectivity and more.\nThis section will cover what types of data exist and how to access them.\n\nThe types of data we will describe here are:\n\n* **Imagery**: The 3d array depicting the ultrastructure, with grayscale values.  \n* **Segmentation**: A 3d array where each voxel has the root id of the segmentation at that location (see next section).  \n* **Meshes**: A representation of the 3d surface of a neuron.  \n* **Skeletons** : A representation of the tree-like structure of a neuron.  \n* **Tables**: Database tables that describe the various types of annotations, such as cell types, synapses, and more.  \n\nIn addition, there are three primary ways to access the data:\n\n* **Neuroglancer** : Neuroglancer is a web-based viewer to explore the 3d data, and offers access to imagery, segmentations, meshes, and annotations.  \n  Its graphical interface, ability to quickly explore data, and share links make it convenient for fast exploration.\n* **Dash web apps**: Web apps that allow fast querying of tables and synaptic connectivity that can also be used to generate complex Neuroglancer links.  \n  Not as flexible as python programmatic access, but it can be used to quickly explore certain features of the data and visualize in Neuroglancer.\n* **Python** : A collection of tools based around the CAVEclient offer a programmatic interface to the data.  \n\n\n\n\nIf you need to look up any particular values or links for the dataset — how to open a Neuroglancer link for it, what annotation tables exist, how to find Dash Apps —\nthe **public MICrONs datastack** has a [useful information page](https://global.daf-apis.com/info/datastack/minnie65_public). Go there if you need to look up basic details about the dataset.\n\nParticularly useful links here are the [Neuroglancer link](https://neuroglancer.neuvue.io/#!%7B%22jsonStateServer%22:%22https://global.daf-apis.com/nglstate/api/v1/post%22,%22navigation%22:%7B%22pose%22:%7B%22position%22:%7B%22voxelSize%22:%5B4.0,4.0,40.0%5D%7D%7D,%22zoomFactor%22:2.0%7D,%22showSlices%22:false,%22layout%22:%22xy-3d%22,%22perspectiveZoom%22:2000.0,%22layers%22:%5B%7B%22type%22:%22image%22,%22source%22:%22precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em%22,%22name%22:%22img%22,%22shader%22:%22#uicontrol%20float%20black%20slider(min=0,%20max=1,%20default=0.0)%5Cn#uicontrol%20float%20white%20slider(min=0,%20max=1,%20default=1.0)%5Cnfloat%20rescale(float%20value)%20%7B%5Cn%20%20return%20(value%20-%20black)%20/%20(white%20-%20black);%5Cn%7D%5Cnvoid%20main()%20%7B%5Cn%20%20float%20val%20=%20toNormalized(getDataValue());%5Cn%20%20if%20(val%20%3C%20black)%20%7B%5Cn%20%20%20%20emitRGB(vec3(0,0,0));%5Cn%20%20%7D%20else%20if%20(val%20%3E%20white)%20%7B%5Cn%20%20%20%20emitRGB(vec3(1.0,%201.0,%201.0));%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20emitGrayscale(rescale(val));%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D,%7B%22type%22:%22segmentation_with_graph%22,%22source%22:%22graphene://https://minnie.microns-daf.com/segmentation/table/minnie65_public%22,%22name%22:%22seg%22,%22selectedAlpha%22:0.3,%22objectAlpha%22:1.0,%22notSelectedAlpha%22:0.0%7D,%7B%22type%22:%22annotation%22,%22filterBySegmentation%22:false,%22bracketShortcutsShowSegmentation%22:true,%22annotationSelectionShowsSegmentation%22:true,%22name%22:%22ann%22%7D%5D,%22selectedLayer%22:%7B%22layer%22:%22ann%22,%22visible%22:true%7D%7D), the [Dash Apps](https://minnie.microns-daf.com/dash/datastack/minnie65_public), and the [list of all annotation tables](https://minnie.microns-daf.com/materialize/views/datastack/minnie65_public) associated with the most recent release version (v795).\n\n## How to reference a neuron\n\nThe dynamic nature of the data means that there is more than one way to reference a neuron, and each way has a slightly different meaning.\n\nThe most frequent way to reference a specific neuron is its **root id**, a unique integer that identifies a specific segmentation, and can be used in numerous places.\nHowever, as proofreading occurs, the segmentation of a cell can change, and each edit creates a new \"version\" of a given neuron that is given its own unique root id.\nRoot ids thus refer to not only a specific cell, but a specific version of that cell.\n\nWhen downloading meshes, querying the database, or browsing in Neuroglancer, we use the **root id** of a cell.\n\nHowever, when using data from different points in time, however, root ids can change and the data might not be consistent across two time points.\nOne way to make this easier is to only use data from one moment in time.\n\nThis is the case for the public database that will be used in the course — all data from the public database is synched up to a single moment in time, but it does mean that the analysis cannot respond to any changes in segmentation.\nIn some cases, in some cases, you might see the root id called a \"segment id\" or an \"object id,\" but they all refer to the same thing.\n\nFor segmentations with a cell body in the volume, we also have a **cell id** (or **soma id**), which is a unique integer that identifies each nucleus in the dataset.\nThe advantage of the soma id is that it remains constant across all versions of a cell, so it can be used to track a cell across time.\nThe disadvantage is that to look up the id at any given time or to load into Neuroglancer, you need to look up the root id.\n\nCell ids can be found in the `nucleus_detection_v0` table in the database, as well as many of the tables that reference cell types.\n\n","srcMarkdownNoYaml":"\n\nOne of the more complicated things about using connectomics data is that it's both highly multimodal — there are images, tables, meshes, and more — and that it has been designed to be dynamic, as the segmentation changes with proofeading and carries changes to synaptic connectivity and more.\nThis section will cover what types of data exist and how to access them.\n\nThe types of data we will describe here are:\n\n* **Imagery**: The 3d array depicting the ultrastructure, with grayscale values.  \n* **Segmentation**: A 3d array where each voxel has the root id of the segmentation at that location (see next section).  \n* **Meshes**: A representation of the 3d surface of a neuron.  \n* **Skeletons** : A representation of the tree-like structure of a neuron.  \n* **Tables**: Database tables that describe the various types of annotations, such as cell types, synapses, and more.  \n\nIn addition, there are three primary ways to access the data:\n\n* **Neuroglancer** : Neuroglancer is a web-based viewer to explore the 3d data, and offers access to imagery, segmentations, meshes, and annotations.  \n  Its graphical interface, ability to quickly explore data, and share links make it convenient for fast exploration.\n* **Dash web apps**: Web apps that allow fast querying of tables and synaptic connectivity that can also be used to generate complex Neuroglancer links.  \n  Not as flexible as python programmatic access, but it can be used to quickly explore certain features of the data and visualize in Neuroglancer.\n* **Python** : A collection of tools based around the CAVEclient offer a programmatic interface to the data.  \n\n\n\n## Dataset Information Hub\n\nIf you need to look up any particular values or links for the dataset — how to open a Neuroglancer link for it, what annotation tables exist, how to find Dash Apps —\nthe **public MICrONs datastack** has a [useful information page](https://global.daf-apis.com/info/datastack/minnie65_public). Go there if you need to look up basic details about the dataset.\n\nParticularly useful links here are the [Neuroglancer link](https://neuroglancer.neuvue.io/#!%7B%22jsonStateServer%22:%22https://global.daf-apis.com/nglstate/api/v1/post%22,%22navigation%22:%7B%22pose%22:%7B%22position%22:%7B%22voxelSize%22:%5B4.0,4.0,40.0%5D%7D%7D,%22zoomFactor%22:2.0%7D,%22showSlices%22:false,%22layout%22:%22xy-3d%22,%22perspectiveZoom%22:2000.0,%22layers%22:%5B%7B%22type%22:%22image%22,%22source%22:%22precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em%22,%22name%22:%22img%22,%22shader%22:%22#uicontrol%20float%20black%20slider(min=0,%20max=1,%20default=0.0)%5Cn#uicontrol%20float%20white%20slider(min=0,%20max=1,%20default=1.0)%5Cnfloat%20rescale(float%20value)%20%7B%5Cn%20%20return%20(value%20-%20black)%20/%20(white%20-%20black);%5Cn%7D%5Cnvoid%20main()%20%7B%5Cn%20%20float%20val%20=%20toNormalized(getDataValue());%5Cn%20%20if%20(val%20%3C%20black)%20%7B%5Cn%20%20%20%20emitRGB(vec3(0,0,0));%5Cn%20%20%7D%20else%20if%20(val%20%3E%20white)%20%7B%5Cn%20%20%20%20emitRGB(vec3(1.0,%201.0,%201.0));%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20emitGrayscale(rescale(val));%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D,%7B%22type%22:%22segmentation_with_graph%22,%22source%22:%22graphene://https://minnie.microns-daf.com/segmentation/table/minnie65_public%22,%22name%22:%22seg%22,%22selectedAlpha%22:0.3,%22objectAlpha%22:1.0,%22notSelectedAlpha%22:0.0%7D,%7B%22type%22:%22annotation%22,%22filterBySegmentation%22:false,%22bracketShortcutsShowSegmentation%22:true,%22annotationSelectionShowsSegmentation%22:true,%22name%22:%22ann%22%7D%5D,%22selectedLayer%22:%7B%22layer%22:%22ann%22,%22visible%22:true%7D%7D), the [Dash Apps](https://minnie.microns-daf.com/dash/datastack/minnie65_public), and the [list of all annotation tables](https://minnie.microns-daf.com/materialize/views/datastack/minnie65_public) associated with the most recent release version (v795).\n\n## How to reference a neuron\n\nThe dynamic nature of the data means that there is more than one way to reference a neuron, and each way has a slightly different meaning.\n\nThe most frequent way to reference a specific neuron is its **root id**, a unique integer that identifies a specific segmentation, and can be used in numerous places.\nHowever, as proofreading occurs, the segmentation of a cell can change, and each edit creates a new \"version\" of a given neuron that is given its own unique root id.\nRoot ids thus refer to not only a specific cell, but a specific version of that cell.\n\nWhen downloading meshes, querying the database, or browsing in Neuroglancer, we use the **root id** of a cell.\n\nHowever, when using data from different points in time, however, root ids can change and the data might not be consistent across two time points.\nOne way to make this easier is to only use data from one moment in time.\n\nThis is the case for the public database that will be used in the course — all data from the public database is synched up to a single moment in time, but it does mean that the analysis cannot respond to any changes in segmentation.\nIn some cases, in some cases, you might see the root id called a \"segment id\" or an \"object id,\" but they all refer to the same thing.\n\nFor segmentations with a cell body in the volume, we also have a **cell id** (or **soma id**), which is a unique integer that identifies each nucleus in the dataset.\nThe advantage of the soma id is that it remains constant across all versions of a cell, so it can be used to track a cell across time.\nThe disadvantage is that to look up the id at any given time or to load into Neuroglancer, you need to look up the root id.\n\nCell ids can be found in the `nucleus_detection_v0` table in the database, as well as many of the tables that reference cell types.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"em_02_dataset_basics.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.546","theme":"cosmo","title":"Dataset Basics","bibliography":["references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}