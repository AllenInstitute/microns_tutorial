{"title":"CAVE Quickstart","markdown":{"yaml":{"title":"CAVE Quickstart","format":{"html":{"toc":true,"code-fold":false}},"execute":{"eval":false,"warning":false},"jupyter":"python3"},"headingText":"Initial Setup","containsRefs":false,"markdown":"\n\nThe **Connectome Annotation Versioning Engine (CAVE)** is a suite of tools developed at the Allen Institute and Seung Lab to manage large connectomics data.  \n\n::: {.callout-important}\nBefore using any programmatic access to the data, [you first need to set up your CAVEclient token](em_py_01_caveclient_setup.html).\n:::\n\n## CAVEclient\n\nMost programmatic access to the CAVE services occurs through CAVEclient, a Python client to access various types of data from the online services.\n\nFull documentation for CAVEclient [is available here](http://caveclient.readthedocs.io).\n\nTo initialize a caveclient, we give it a **datastack**, which is a name that defines a particular combination of imagery, segmentation, and annotation database.\nFor the MICrONs public data, we use the datastack name `minnie65_public`.\n\n## CAVEclient Basics\n\nThe most frequent use of the CAVEclient is to query the database for annotations like synapses.\nAll database functions are under the `client.materialize` property.\nTo see what tables are available, use the `get_tables` function:\n\nFor each table, you can see the metadata describing that table.\nFor example, let's look at the `nucleus_detection_v0` table:\n\nYou get a dictionary of values. Two fields are particularly important: the `description`, which offers a text description of the contents of the table and `voxel_resolution` which defines how the coordinates in the table are defined, in nm/voxel.\n\n## Querying Tables\n\nTo get the contents of a table, use the `query_table` function.\nThis will return the whole contents of a table without any filtering, up to for a maximum limit of 200,000 rows.\nThe table is returned as a Pandas DataFrame and you can immediately use standard Pandas function on it.\n\n::: {.callout-caution}\nWhile most tables are small enough to be returned in full, the synapse table has hundreds of millions of rows and is too large to download this way\n:::\n\nTables have a collection of columns, some of which specify point in space (columns ending in `_position`), some a root id (ending in `_root_id`), and others that contain other information about the object at that point.\nBefore describing some of the most important tables in the database, it's useful to know about a few advanced options that apply when querying any table.\n\n* `desired_resolution` : This parameter allows you to convert the columns specifying spatial points to different resolutions.\nMany tables are stored at a resolution of 4x4x40 nm/voxel, for example, but you can convert to nanometers by setting `desired_resolution=[1,1,1]`.\n* `split_positions` : This parameter allows you to split the columns specifying spatial points into separate columns for each dimension.\nThe new column names will be the original column name with `_x`, `_y`, and `_z` appended.\n* `select_columns` : This parameter allows you to get only a subset of columns from the table.\nOnce you know exactly what you want, this can save you some cleanup.\n* `limit` : This parameter allows you to limit the number of rows returned.\nIf you are just testing out a query or trying to inspect the kind of data within a table, you can set this to a small number to make sure it works before downloading the whole table.\nNote that this will show a warning so that you don't accidentally limit your query when you don't mean to.\n\nFor example, using all of these together:\n\n## Filtering Queries\n\nFiltering tables so that you only get data about certain rows back is a very common operation.\nWhile there are filtering options in the `query_table` function ([see documentation for more details](https://caveclient.readthedocs.io/en/latest/guide/materialization.html)), a more\nunified filter interface is available through a \"table manager\" interface.\n\nRather than passing a table name to the `query_table` function, `client.materialize.tables` has a subproperty for each table in the database that can be used to filter that table.\n\nThe general pattern for usage is\n\n``` python\nclient.materialize.tables.{table_name}({filter options}).query({format and timestamp options})\n```\n\nwhere `{table_name}` is the name of the table you want to filter, `{filter options}` is a collection of arguments for filtering the query, and `{format and timestamp options}` are those parameters controlling the format and timestamp of the query.\n\nFor example, let's look at the table `aibs_soma_nuc_metamodel_preds_v117`, which has cell type predictions across the dataset.\nWe can get the whole table as a DataFrame:\n\nand we can add similar formatting options as in the last section to the query function:\n\nHowever, now we can also filter the table to get only cells that are predicted to have cell type `\"BC\"` (for \"basket cell\").\n\nor maybe we just want the cell types for a particular collection of root ids:\n\nYou can get a list of all parameters than be used for querying with the standard IPython/Jupyter docstring functionality, e.g. `client.materialize.tables.aibs_soma_nuc_metamodel_preds_v117`.\n\n::: {.callout-caution}\nUse of this functionality will show a brief warning that the interface is experimental. This is because the interface is still being developed and may change in the near future in response to user feedback.\n:::\n\n## Querying Synapses\n\nWhile synapses are stored as any other table in the database, in this case `synapses_pni_2`, this table is much larger than any other table at more than 337 million rows, and it works best when queried in a different way.\n\nThe `synapse_query` function allows you to query the synapse table in a more convenient way than most other tables.\nIn particular, the `pre_ids` and `post_ids` let you specify which root id (or collection of root ids) you want to query, with pre_ids indicating the collection of presynaptic neurons and post_ids the collection of postsynaptic neurons.\n\nUsing both `pre_ids` and `post_ids` in one call is effectively a logical AND, returning only those synapses from neurons in the list of `pre_ids` that target neurons in the list of `post_ids`.\n\nLet's look at one particular example.\n\nNote that synapse queries always return the list of every synapse between the neurons in the query, even if there are multiple synapses between the same pair of neurons.\n\nA common pattern to generate a list of connections between unique pairs of neurons is to group by the root ids of the presynaptic and postsynaptic neurons and then count the number of synapses between them.\nFor example, to get the number of synapses from this neuron onto every other neuron, ordered\n","srcMarkdownNoYaml":"\n\nThe **Connectome Annotation Versioning Engine (CAVE)** is a suite of tools developed at the Allen Institute and Seung Lab to manage large connectomics data.  \n\n::: {.callout-important}\n## Initial Setup\nBefore using any programmatic access to the data, [you first need to set up your CAVEclient token](em_py_01_caveclient_setup.html).\n:::\n\n## CAVEclient\n\nMost programmatic access to the CAVE services occurs through CAVEclient, a Python client to access various types of data from the online services.\n\nFull documentation for CAVEclient [is available here](http://caveclient.readthedocs.io).\n\nTo initialize a caveclient, we give it a **datastack**, which is a name that defines a particular combination of imagery, segmentation, and annotation database.\nFor the MICrONs public data, we use the datastack name `minnie65_public`.\n\n## CAVEclient Basics\n\nThe most frequent use of the CAVEclient is to query the database for annotations like synapses.\nAll database functions are under the `client.materialize` property.\nTo see what tables are available, use the `get_tables` function:\n\nFor each table, you can see the metadata describing that table.\nFor example, let's look at the `nucleus_detection_v0` table:\n\nYou get a dictionary of values. Two fields are particularly important: the `description`, which offers a text description of the contents of the table and `voxel_resolution` which defines how the coordinates in the table are defined, in nm/voxel.\n\n## Querying Tables\n\nTo get the contents of a table, use the `query_table` function.\nThis will return the whole contents of a table without any filtering, up to for a maximum limit of 200,000 rows.\nThe table is returned as a Pandas DataFrame and you can immediately use standard Pandas function on it.\n\n::: {.callout-caution}\nWhile most tables are small enough to be returned in full, the synapse table has hundreds of millions of rows and is too large to download this way\n:::\n\nTables have a collection of columns, some of which specify point in space (columns ending in `_position`), some a root id (ending in `_root_id`), and others that contain other information about the object at that point.\nBefore describing some of the most important tables in the database, it's useful to know about a few advanced options that apply when querying any table.\n\n* `desired_resolution` : This parameter allows you to convert the columns specifying spatial points to different resolutions.\nMany tables are stored at a resolution of 4x4x40 nm/voxel, for example, but you can convert to nanometers by setting `desired_resolution=[1,1,1]`.\n* `split_positions` : This parameter allows you to split the columns specifying spatial points into separate columns for each dimension.\nThe new column names will be the original column name with `_x`, `_y`, and `_z` appended.\n* `select_columns` : This parameter allows you to get only a subset of columns from the table.\nOnce you know exactly what you want, this can save you some cleanup.\n* `limit` : This parameter allows you to limit the number of rows returned.\nIf you are just testing out a query or trying to inspect the kind of data within a table, you can set this to a small number to make sure it works before downloading the whole table.\nNote that this will show a warning so that you don't accidentally limit your query when you don't mean to.\n\nFor example, using all of these together:\n\n## Filtering Queries\n\nFiltering tables so that you only get data about certain rows back is a very common operation.\nWhile there are filtering options in the `query_table` function ([see documentation for more details](https://caveclient.readthedocs.io/en/latest/guide/materialization.html)), a more\nunified filter interface is available through a \"table manager\" interface.\n\nRather than passing a table name to the `query_table` function, `client.materialize.tables` has a subproperty for each table in the database that can be used to filter that table.\n\nThe general pattern for usage is\n\n``` python\nclient.materialize.tables.{table_name}({filter options}).query({format and timestamp options})\n```\n\nwhere `{table_name}` is the name of the table you want to filter, `{filter options}` is a collection of arguments for filtering the query, and `{format and timestamp options}` are those parameters controlling the format and timestamp of the query.\n\nFor example, let's look at the table `aibs_soma_nuc_metamodel_preds_v117`, which has cell type predictions across the dataset.\nWe can get the whole table as a DataFrame:\n\nand we can add similar formatting options as in the last section to the query function:\n\nHowever, now we can also filter the table to get only cells that are predicted to have cell type `\"BC\"` (for \"basket cell\").\n\nor maybe we just want the cell types for a particular collection of root ids:\n\nYou can get a list of all parameters than be used for querying with the standard IPython/Jupyter docstring functionality, e.g. `client.materialize.tables.aibs_soma_nuc_metamodel_preds_v117`.\n\n::: {.callout-caution}\nUse of this functionality will show a brief warning that the interface is experimental. This is because the interface is still being developed and may change in the near future in response to user feedback.\n:::\n\n## Querying Synapses\n\nWhile synapses are stored as any other table in the database, in this case `synapses_pni_2`, this table is much larger than any other table at more than 337 million rows, and it works best when queried in a different way.\n\nThe `synapse_query` function allows you to query the synapse table in a more convenient way than most other tables.\nIn particular, the `pre_ids` and `post_ids` let you specify which root id (or collection of root ids) you want to query, with pre_ids indicating the collection of presynaptic neurons and post_ids the collection of postsynaptic neurons.\n\nUsing both `pre_ids` and `post_ids` in one call is effectively a logical AND, returning only those synapses from neurons in the list of `pre_ids` that target neurons in the list of `post_ids`.\n\nLet's look at one particular example.\n\nNote that synapse queries always return the list of every synapse between the neurons in the query, even if there are multiple synapses between the same pair of neurons.\n\nA common pattern to generate a list of connections between unique pairs of neurons is to group by the root ids of the presynaptic and postsynaptic neurons and then count the number of synapses between them.\nFor example, to get the number of synapses from this neuron onto every other neuron, ordered\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"em_py_02_cave_quickstart.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.546","theme":"cosmo","title":"CAVE Quickstart","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}