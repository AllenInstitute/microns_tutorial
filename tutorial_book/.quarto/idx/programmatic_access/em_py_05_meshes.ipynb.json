{"title":"Meshes","markdown":{"yaml":{"title":"Meshes","format":{"html":{"toc":true,"code-fold":false}},"execute":{"eval":false,"warning":false},"jupyter":"python3","bibliography":["../references.bib"]},"headingText":"Downloading Meshes","containsRefs":false,"markdown":"\n\nWhen trying to understand the fine 3d morphology of a neuron (e.g. features under 1 micron in scale), meshes are a particularly useful representation.\nMore precisely, a mesh is a collection of vertices and faces that define a 3d surface.\nThe exact meshes that one sees in Neuroglancer can also be loaded for analysis and visualization in other tools.\n\n\nThe easiest tool for downloading MICrONs meshes is [Meshparty](https://github.com/sdorkenw/MeshParty), which is a python module that can be installed with `pip install meshparty`.\nDocumentation for Meshparty can be found [here](https://meshparty.readthedocs.io/en/latest/).\n\nOnce installed, the typical way of getting meshes is by using a \"MeshMeta\" client that is told both the internet location of the meshes (`cv_path`) and a local directory in which to store meshes (`disk_cache_path`).\nOnce initialized, the MeshMeta client can be used to download meshes for a given segmentation using its root id (`seg_id`).\nThe following code snippet shows how to download an example mesh using a directory \"`meshes`\" as the local storage folder. \n\n::: {.callout-important}\n## Initial Setup\nBefore using any programmatic access to the data, [you first need to set up your CAVEclient token](em_py_01_caveclient_setup.html).\n:::\n\nOne convenience of using the `MeshMeta` approach is that if you have already downloaded a mesh for with a given root id, it will be loaded from disk rather than re-downloaded.\n\nIf you have to download many meshes, it is somewhat faster to use the bulk `download_meshes` function and use multiple threads via the `n_threads` argument. If you download them to the same folder used for the MeshMeta object, they can be loaded through the same interface.\n\n::: {.callout-caution}\n## File size\nMeshes can be hundresds of megabytes in size, so be careful about downloading too many if the internet is not acting well or your computer doesn't have much disk space!\n:::\n\n## Healing Mesh Gaps\n![Example of a continuous neuron whose mesh has a gap](../img/mesh-discontinuity.png)\n\nMany meshes are not actually fully continuous due to small gaps in the segmentation.\nHowever, information collected during proofreading allows one to partially repair these gaps by adding in links where the segmentation was merged across a small gap.\nIf you are just visualizaing a mesh, these gaps are not a problem, but if you want to do analysis on the mesh, you will want to heal these gaps.\nConveniently, there's a function to do this:\n\n## Properties\n\nMeshes have a large number of properties, many of which come from being based on the [Trimesh](https://trimsh.org/) library's mesh format, and others being specific to MeshParty.\n\nSeveral of the most important properties are:\n\n* `mesh.vertices` : An `N x 3` list of vertices and their 3d location in nanometers, where `N` is the number of vertices.\n* `mesh.faces` : An `P x 3` list of integers, with each row specifying a triangle of connected vertex indices.\n* `mesh.edges` : An `M x 2` list of integers, with each row specifying a pair of connected vertex indices based off of faces.\n* `mesh.edges` : An `M x 2` list of integers, with each row specifying a pair of connected vertex indices based off of faces.\n* `mesh.link_edges` : An `M_l x 2` list of integers, with each row specifying a pair of \"link edges\" that were used to heal gaps based on proofreading edits.\n* `mesh.graph_edges` : An `(M+M_l) x 2` list of integers, with each row specifying a pair of graph edges, which is the collection of both `mesh.edges` and `mesh.link_edges`.\n* `mesh.csgraph` : A [Scipy Compressed Sparse Graph](https://docs.scipy.org/doc/scipy/reference/sparse.csgraph.html) representation of the mesh as an `NxN` graph of vertices connected to one another using graph edges and with edge weights being the distance between vertices. This is particularly useful for computing shortest paths between vertices.\n\n::: {.calloute-warning}\nMICrONs meshes are not generally \"watertight\", a property that would enable a number of properties to be computed natively by Trimesh. Because of this, Trimesh-computed properties relating to solid forms or volumes like `mesh.volume` or `mesh.center_mass` do not have sensible values and other approaches should be taken. Unfortunately, because of the Trimesh implementation of these properties it is up to the user to be aware of this issue.\n:::\n\n## Visualization\n\nThere are a variety of tools for visualizing meshes in python.\nMeshParty interfaces with VTK, a powerful but complex data visualization library that does not always work well in python.\nThe basic pattern for MeshParty's VTK integration is to create one or more \"actors\" from the data, and then pass those to a renderer that can be displayed in an interactive approach.\nThe following code snippet shows how to visualize a mesh using this approach.\n\nNote that by default, neurons will appear upside down because the coordinate system of the dataset has the y-axis value increasing along the \"downward\" pia to white matter axis.\n\nMore documentation on the MeshParty VTK visualization can be [found here](https://meshparty.readthedocs.io/en/latest/source/meshparty.html).\n\nOther tools worth exploring are:\n\n* [PyVista](https://docs.pyvista.org/)\n* [Polyscope](https://polyscope.run/)\n* [Vedo](https://vedo.embl.es/)\n* [MeshLab](https://www.meshlab.net/)\n* If you have some existing experience, [Blender](https://www.blender.org/) (see Blender integration by our friends behind [Navis](https://navis.readthedocs.io/en/latest/source/blender.html), a fly-focused framework analyzing connectomics data).\n\n\n## Masking\n\nOne of the most common operations on meshes is to mask them to a particular region of interest.\nThis can be done by \"masking\" the mesh with a boolean array of length `N` where `N` is the number of vertices in the mesh, with `True` where the vertex should be kept and `False` where it should be omitted.\nThere are several convenience functions to generate common masks in the [Mesh Filters](https://meshparty.readthedocs.io/en/latest/source/meshparty.html#module-meshparty.mesh_filters) module.\n\nIn the following example, we will first mask out all vertices that aren't part of the largest connected component of the mesh (i.e. get rid of floating vertices that might arise due to internal surfaces) and then mask out all vertices that are more than 20,000 nm away from the soma center.\n\nThis resulting mesh is just a small cutout around the soma.\n![Soma cutout from a full-neuron mesh](../img/soma_mesh_cutout.png)\n","srcMarkdownNoYaml":"\n\nWhen trying to understand the fine 3d morphology of a neuron (e.g. features under 1 micron in scale), meshes are a particularly useful representation.\nMore precisely, a mesh is a collection of vertices and faces that define a 3d surface.\nThe exact meshes that one sees in Neuroglancer can also be loaded for analysis and visualization in other tools.\n\n## Downloading Meshes\n\nThe easiest tool for downloading MICrONs meshes is [Meshparty](https://github.com/sdorkenw/MeshParty), which is a python module that can be installed with `pip install meshparty`.\nDocumentation for Meshparty can be found [here](https://meshparty.readthedocs.io/en/latest/).\n\nOnce installed, the typical way of getting meshes is by using a \"MeshMeta\" client that is told both the internet location of the meshes (`cv_path`) and a local directory in which to store meshes (`disk_cache_path`).\nOnce initialized, the MeshMeta client can be used to download meshes for a given segmentation using its root id (`seg_id`).\nThe following code snippet shows how to download an example mesh using a directory \"`meshes`\" as the local storage folder. \n\n::: {.callout-important}\n## Initial Setup\nBefore using any programmatic access to the data, [you first need to set up your CAVEclient token](em_py_01_caveclient_setup.html).\n:::\n\nOne convenience of using the `MeshMeta` approach is that if you have already downloaded a mesh for with a given root id, it will be loaded from disk rather than re-downloaded.\n\nIf you have to download many meshes, it is somewhat faster to use the bulk `download_meshes` function and use multiple threads via the `n_threads` argument. If you download them to the same folder used for the MeshMeta object, they can be loaded through the same interface.\n\n::: {.callout-caution}\n## File size\nMeshes can be hundresds of megabytes in size, so be careful about downloading too many if the internet is not acting well or your computer doesn't have much disk space!\n:::\n\n## Healing Mesh Gaps\n![Example of a continuous neuron whose mesh has a gap](../img/mesh-discontinuity.png)\n\nMany meshes are not actually fully continuous due to small gaps in the segmentation.\nHowever, information collected during proofreading allows one to partially repair these gaps by adding in links where the segmentation was merged across a small gap.\nIf you are just visualizaing a mesh, these gaps are not a problem, but if you want to do analysis on the mesh, you will want to heal these gaps.\nConveniently, there's a function to do this:\n\n## Properties\n\nMeshes have a large number of properties, many of which come from being based on the [Trimesh](https://trimsh.org/) library's mesh format, and others being specific to MeshParty.\n\nSeveral of the most important properties are:\n\n* `mesh.vertices` : An `N x 3` list of vertices and their 3d location in nanometers, where `N` is the number of vertices.\n* `mesh.faces` : An `P x 3` list of integers, with each row specifying a triangle of connected vertex indices.\n* `mesh.edges` : An `M x 2` list of integers, with each row specifying a pair of connected vertex indices based off of faces.\n* `mesh.edges` : An `M x 2` list of integers, with each row specifying a pair of connected vertex indices based off of faces.\n* `mesh.link_edges` : An `M_l x 2` list of integers, with each row specifying a pair of \"link edges\" that were used to heal gaps based on proofreading edits.\n* `mesh.graph_edges` : An `(M+M_l) x 2` list of integers, with each row specifying a pair of graph edges, which is the collection of both `mesh.edges` and `mesh.link_edges`.\n* `mesh.csgraph` : A [Scipy Compressed Sparse Graph](https://docs.scipy.org/doc/scipy/reference/sparse.csgraph.html) representation of the mesh as an `NxN` graph of vertices connected to one another using graph edges and with edge weights being the distance between vertices. This is particularly useful for computing shortest paths between vertices.\n\n::: {.calloute-warning}\nMICrONs meshes are not generally \"watertight\", a property that would enable a number of properties to be computed natively by Trimesh. Because of this, Trimesh-computed properties relating to solid forms or volumes like `mesh.volume` or `mesh.center_mass` do not have sensible values and other approaches should be taken. Unfortunately, because of the Trimesh implementation of these properties it is up to the user to be aware of this issue.\n:::\n\n## Visualization\n\nThere are a variety of tools for visualizing meshes in python.\nMeshParty interfaces with VTK, a powerful but complex data visualization library that does not always work well in python.\nThe basic pattern for MeshParty's VTK integration is to create one or more \"actors\" from the data, and then pass those to a renderer that can be displayed in an interactive approach.\nThe following code snippet shows how to visualize a mesh using this approach.\n\nNote that by default, neurons will appear upside down because the coordinate system of the dataset has the y-axis value increasing along the \"downward\" pia to white matter axis.\n\nMore documentation on the MeshParty VTK visualization can be [found here](https://meshparty.readthedocs.io/en/latest/source/meshparty.html).\n\nOther tools worth exploring are:\n\n* [PyVista](https://docs.pyvista.org/)\n* [Polyscope](https://polyscope.run/)\n* [Vedo](https://vedo.embl.es/)\n* [MeshLab](https://www.meshlab.net/)\n* If you have some existing experience, [Blender](https://www.blender.org/) (see Blender integration by our friends behind [Navis](https://navis.readthedocs.io/en/latest/source/blender.html), a fly-focused framework analyzing connectomics data).\n\n\n## Masking\n\nOne of the most common operations on meshes is to mask them to a particular region of interest.\nThis can be done by \"masking\" the mesh with a boolean array of length `N` where `N` is the number of vertices in the mesh, with `True` where the vertex should be kept and `False` where it should be omitted.\nThere are several convenience functions to generate common masks in the [Mesh Filters](https://meshparty.readthedocs.io/en/latest/source/meshparty.html#module-meshparty.mesh_filters) module.\n\nIn the following example, we will first mask out all vertices that aren't part of the largest connected component of the mesh (i.e. get rid of floating vertices that might arise due to internal surfaces) and then mask out all vertices that are more than 20,000 nm away from the soma center.\n\nThis resulting mesh is just a small cutout around the soma.\n![Soma cutout from a full-neuron mesh](../img/soma_mesh_cutout.png)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"em_py_05_meshes.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.546","theme":"cosmo","title":"Meshes","jupyter":"python3","bibliography":["../references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}